---
sidebar_position: 4
---

# Infrastructure guide

conda-forge operates at a scale where automation is not an option.
Most processes are automated so human intervention is kept to a minimum.

In this page, we discuss the different elements involved in each stage of the [conda packaging life cycle](/docs/user/life-cycle/index.md):

1. Initial submission to `staged-recipes`
2. Feedstock changes:
   - A. Repository initialization
   - B. Automated maintenance updates
   - C. PRs submitted by users
3. Package building
4. Package validation
5. Package publication
6. Post-publication:
   - A. Repodata patch
   - B. Mark a package as broken
   - C. Archive the feedstock

## 1. Initial submission to staged-recipes

The `conda-forge/staged-recipes` uses several pieces of infrastructure.

On pull requests:

- Package building pipelines. These are slightly different than the ones running in feedstocks (they are not automatically generated by `conda-smithy`, but they do use the same underlying components).
- The linter provided by `conda-smithy recipe-lint`, run by `@conda-forge-linter`.
- Auto-labeling logic, run by Github Actions workflows.

On pushes to `main`:

- Create and initialize the new feedstocks.

Authenticated services involved:

- Github, with permissions for:
    - Repository creation
- Azure Pipelines
- Travis CI
- Other CI providers?

## 2. Feedstock changes:

A feedstock can receive changes for several reasons.

Pushes to `main` or other branches:

- The automated initialization commits following the approval in `staged-recipes`. These are generated by `conda-smithy`.
- Automated maintenance commits triggered from `admin-migrations`.
- Rerender requests handled by instances of `conda-forge/webservices-dispatch-action` and triggered by the admin web service.

Automatic pull requests can be opened by...

- `@conda-forge-linter`, responding to some issues with titles like `@conda-forge-admin, please...`.
- `@regro-cf-autotick-bot`, handling migrations and new versions being available.

...and closed by:

- `conda-forge/automerge-action`, if labeled adequately.

On an open pull request:

- The building pipelines (more [below](#3-package-building)).
- The linter provided by `conda-smithy recipe-lint`, run by `@conda-forge-linter`.
- The `@conda-forge-admin, please...` command comments, answered by `@conda-forge-linter`.

On issues:

- `@conda-forge-admin, please...` command issues, handled by `@conda-forge-linter`.

## 3. Package building

The pipelines that build conda packages are used for both pull requests and push events in `main` and other branches. The only difference is that the packages built during a pull request are not uploaded to the staging channel. Maintaining these up-to-date across all feedstocks involves a number of repositories:

- `conda-smithy` is in charge of generating the CI pipelines themselves, together with the supporting scripts and configuration files. These pipelines and scripts can rely on code and data defined in the repositories below.
- `conda-forge-ci-setup-feedstock` provides the code needed to prepare and homogeneize the CI runners across providers.
- `conda-forge-pinning-feedstock` defines which versions are supported for a number of runtimes and libraries, as well as the compilers used for certain languages and platforms.
- `docker-images` builds the standardized container images for Linux runners.
  This repository has additional authentication needs for Docker Hub, Quay.io.

The pipelines can run on a number of CI providers supported by `conda-smithy`, including:

- Azure DevOps Pipelines
- Drone.io
- Travis CI
- Circle CI

Registration of hooks and triggers is also done by the `conda-smithy` app.

:::tip
`conda-smithy` supports more CI providers. Check [the repo][conda-smithy] for more details.
:::

Authenticated services involved:

- Anaconda.org uploads to `cf-staging`

## 4. Package validation and publication

Once built on `main` (or other branches), the conda packages are uploaded to an intermediary channel named `cf-staging`. From there, the packages are downloaded by the validation server and, if successful, copied over to `conda-forge` itself.

- The validation logic is defined at `conda-forge/artifact-validation`
- If problematic, the results of the validation are posted as issues in the same repo.
- This logic runs at `conda-forge/conda-forge-webservices`. This webapp also copies the artifacts from `cf-staging` to `conda-forge`.
- Part of the validation includes checking for cross-package clobbering. The list of authorized feedstocks per package name is maintained at `conda-forge/feedstock-outputs`.
- Some further analysis might be performed _after_ publication.

Authenticated services involved:

- Anaconda.org uploads to `conda-forge`
- The `conda-forge-webservices` app deployment itself (currently at Heroku)
- (?) Post new issues to `conda-forge/artifact-validation`

## 5. Post-publication

WIP.

### 5A. Repodata patch

WIP.

### 5B. Mark a package as broken

WIP.

### 5C. Archive the feedstock

WIP.

<!-- LINKS -->

[conda-smithy]: https://github.com/conda-forge/conda-smithy
